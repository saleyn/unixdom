%%%----------------------------------------------------------------------
%%% File    : unixdom.erl
%%% Summary : EDTK implementation of UNIX domain socket driver (incomplete!)
%%%
%%%
%%% NOTICE: This file was generated by the tools of the Erlang Driver
%%%         toolkit.  Do not edit this file by hand unless you know
%%%         what you're doing!
%%%
%%% Copyright (c) 2004, Scott Lystig Fritchie. All rights reserved.
%%% 5-Oct-2007 - Minor TCP compatibility additions done by Serge Aleynikov <saleyn@gmail.com>
%%% See the file "LICENSE" at the top of the source distribution for
%%% full license terms.
%%%
%%%----------------------------------------------------------------------

-module(unixdom).
-include("unixdom.hrl").

%% Xref with erl_driver_tk.h's PIPE_DRIVER_TERM_* values
-define(T_NIL, 0).
-define(T_ATOM, 1).
-define(T_PORT, 2).
-define(T_INT, 3).
-define(T_TUPLE, 4).
-define(T_BINARY, 5).
-define(T_STRING, 6).
-define(T_LIST, 7).

%% External exports

%% Added by Serge Aleynikov <saleynãgmail.com> to allow UDS socket wrapping to `gen_tcp'.
-export([listen/3, connect/3, accept/1, accept/2, async_accept/1, tcp_close/2, set_sockopt/2]).

-export([start/0, start_pipe/0]).
-export([shutdown/1]).
-export([debug/2, io_list_len/1]).
-export([
         null/1, 
         open/3, 
         getfd/2, 
         closefd/2, 
         sendfd/3, 
         receivefd/2, 
         close/2, 
         write/3, 
         read/3
        ]).

start() ->
    {ok, Path} = load_path(?DRV_NAME ++ ".so"),
    erl_ddll:start(),
    ok = erl_ddll:load_driver(Path, ?DRV_NAME),
    case open_port({spawn, ?DRV_NAME}, []) of
        P when is_port(P) ->
            {ok, P};
        Err ->
            Err
    end.

start_pipe() ->
    {ok, PipeMain} = load_path("pipe-main"),
    {ok, ShLib} = load_path("./unixdom.so"),
    Cmd = PipeMain ++ "/pipe-main " ++ ShLib ++ "/unixdom.so",
    case open_port({spawn, Cmd}, [exit_status, binary, use_stdio, {packet, 4}]) of
        P when is_port(P) ->
            {ok, P};
        Err ->
            Err
    end.

shutdown(Port) when is_port(Port) ->
    catch erlang:port_close(Port),
    %% I was under the impression you'd always get a message sent to
    %% you in this case, so this receive is to keep your mailbox from
    %% getting cluttered.  Hrm, well, sometimes the message does
    %% not arrive at all!
    receive
        {'EXIT', Port, normal} -> {ok, normal};
        {'EXIT', Port, Err}    -> {error, Err}
    after 0                    -> {ok, normall} % XXX is 0 too small?
        
    end.

debug(Port, Flags) when is_port(Port), integer(Flags) ->
    case catch erlang:port_command(Port, <<?S1_DEBUG, Flags:32>>) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX too drastic?
    end.

null(Port
        ) when is_port(Port) -> % TODO: Add additional constraints here
    IOList_____ = <<?S1_NULL>>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

open(Port,
     Filename, 
     Flags
        ) when is_port(Port) -> % TODO: Add additional constraints here
    {FilenameBinOrList, FilenameLen} = serialize_contiguously(Filename, 1),
    IOList_____ = [ <<?S1_OPEN,
            FilenameLen:32/integer>>,           % I/O list length
          FilenameBinOrList,
          <<
          Flags:32/integer
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

getfd(Port,
     Fd
        ) when is_port(Port) -> % TODO: Add additional constraints here
    {valmap_fd, FdIndex} = Fd,
    IOList_____ = <<?S1_GETFD,
            FdIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

closefd(Port,
     Fd
        ) when is_port(Port) -> % TODO: Add additional constraints here
    IOList_____ = <<?S1_CLOSEFD,
          Fd:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

sendfd(Port,
     Unixdom_Fd, 
     Fd_To_Be_Sent
        ) when is_port(Port) -> % TODO: Add additional constraints here
    IOList_____ = <<?S1_SENDFD,
          Unixdom_Fd:32/integer, 
          Fd_To_Be_Sent:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

receivefd(Port,
     Unixdom_Fd
        ) when is_port(Port) -> % TODO: Add additional constraints here
    IOList_____ = <<?S1_RECEIVEFD,
          Unixdom_Fd:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

close(Port,
     Fd
        ) when is_port(Port) -> % TODO: Add additional constraints here
    {valmap_fd, FdIndex} = Fd,
    IOList_____ = <<?S1_CLOSE,
            FdIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

write(Port,
     Fd, 
     Ptr
        ) when is_port(Port) -> % TODO: Add additional constraints here
    {valmap_fd, FdIndex} = Fd,
    {PtrBinOrList, PtrLen} = serialize_contiguously(Ptr, 0),
    IOList_____ = [ <<?S1_WRITE,
            FdIndex:32/integer, 
            PtrLen:32/integer>>,                % I/O list length
          PtrBinOrList,
          <<
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

read(Port,
     Fd, 
     Size
        ) when is_port(Port) -> % TODO: Add additional constraints here
    {valmap_fd, FdIndex} = Fd,
    IOList_____ = <<?S1_READ,
            FdIndex:32/integer, 
          Size:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

    
%%%
%%% Internal functions.
%%%

load_path(Filename) ->
    case catch code:which(list_to_existing_atom(?DRV_NAME)) of
    File when is_list(File) ->
        Path = filename:dirname(filename:dirname(File)) ++ "/priv",
        case file:read_file_info(Path ++ "/" ++ Filename) of
        {ok, _} -> {ok, Path};
        _ -> {error, lists:flatten(io_lib:format("Error: ~s not found in code path: ~s", [Filename, Path]))}
        end;
    _ ->
        {error, ?DRV_NAME ++ " not found!"}
    end.

%%%
%%% Note that an 'xtra_return' that only returns one item in its
%%% tuple will return {Port, ok, {Thingie}}, so we'll return
%%% {ok, {Thingie}}, which is *sooooooo* maddening because I keep
%%% forgetting the extra tuple wrapper.  So, if there's only one
%%% thingie in the return tuple, strip it off: {ok, Thingie}
%%%

get_port_reply(Port) when is_port(Port) ->
    receive
        {Port, ok} = T -> proc_reply(T);
        {Port, ok, {_M}} = T -> proc_reply(T);
        {Port, ok, _M} = T -> proc_reply(T);
        {Port, error, {_Reason}} = T -> proc_reply(T);
        {Port, error, _Reason} = T -> proc_reply(T);
        %% Pipe driver messages
        {Port, {data, Bytes}} -> proc_reply(pipedrv_deser(Port, Bytes));
        {'EXIT', Port, Reason} -> throw({port_error, Reason});  % XXX too drastic?
        {Port, Reason} -> throw({port_error, Reason})   % XXX too drastic?
    end.

%% This function exists to provide consistency of replies 
%% given by linked-in and pipe drivers.  The "receive" statement
%% in get_port_reply/1 is specific because we want it to be
%% very selective about what it will grab out of the mailbox.
proc_reply({Port, ok}) when is_port(Port) ->
    ok;
proc_reply({Port, ok, {M}}) when is_port(Port) ->
    {ok, M};
proc_reply({Port, ok, M}) when is_port(Port) ->
    {ok, M};
proc_reply({Port, error, {Reason}}) when is_port(Port) ->
    {error, Reason};
proc_reply({Port, error, Reason}) when is_port(Port) ->
    {error, Reason}.


%%% io_list_len() is an extremely useful function.  BEAM has got this
%%% implemented quite efficiently in C.  It would be *fabulous* to be able
%%% to use it from Erlang via a BIF.

io_list_len(B) when binary(B) -> {B, size(B)};
io_list_len(L) when list(L) -> io_list_len(L, 0).
io_list_len([H|T], N) ->
    if
        H >= 0, H =< 255 -> io_list_len(T, N+1);
        list(H) -> io_list_len(T, io_list_len(H,N));
        binary(H) -> io_list_len(T, size(H) + N);
        true -> throw({error, partial_len, N})
    end;
io_list_len(H, N) when binary(H) -> 
    size(H) + N;
io_list_len([], N) -> 
    N.

%%% We need to make the binary thing we're passing in contiguous
%%% because the C function we're calling is expecting a single
%%% contiguous buffer.  If IOList is ["Hello, ", <<"World">>, "!"],
%%% that binary in the middle element will end up with the argument
%%% spanning three parts of an ErlIOVec.  If that happens, then we'd
%%% have to have the driver do the dirty work of putting the argument
%%% into a single contiguous buffer.
%%%
%%% Frankly, we're lazy, and this code is short and won't be much
%%% slower than doing it in C.

%%% 2nd arg: if 1, NUL-terminate the IOList

serialize_contiguously(B, 0) when binary(B) ->
    {B, size(B)};
serialize_contiguously([B], 0) when binary(B) ->
    {B, size(B)};
serialize_contiguously(IOList, 1) ->
    serialize_contiguously([IOList, 0], 0);
serialize_contiguously(IOList, 0) ->
    B = list_to_binary(IOList),
    {B, size(B)}.


%% pipedrv_deser/2 -- Deserialize the term that the pipe driver is
%% is returning to Erlang.  The pipe driver doesn't know it's a pipe
%% driver, it thinks it's a linked-in driver, so it tries to return
%% an arbitrary Erlang term to us.  The pipe-main program is sneaky:
%% it has a driver_output_term() function that serializes the term
%% that the driver built.  With the help of a list-as-stack, we
%% deserialize that term.

pipedrv_deser(Port, B) ->
    pipedrv_deser(Port, B, []).

pipedrv_deser(_Port, <<>>, []) ->
    throw(icky_i_think);
pipedrv_deser(_Port, <<>>, [T]) ->
    T;
pipedrv_deser(Port, <<?T_NIL:8, Rest/binary>>, Stack) ->
    pipedrv_deser(Port, Rest, [foo___foo_nil___|Stack]);
pipedrv_deser(Port, <<?T_ATOM:8, Len:8, Rest/binary>>, Stack) ->
    <<A:Len/binary, Rest2/binary>> = Rest,
    pipedrv_deser(Port, Rest2, [list_to_atom(binary_to_list(A))|Stack]);
pipedrv_deser(Port, <<?T_PORT:8, _P:32/unsigned, Rest/binary>>, Stack) ->
    %% The pipe driver tried sending us a port, but it cannot know what
    %% port ID was assigned to this port, so we'll assume it is Port.
    pipedrv_deser(Port, Rest, [Port|Stack]);
pipedrv_deser(Port, <<?T_INT:8, I:32/signed, Rest/binary>>, Stack) ->
    pipedrv_deser(Port, Rest, [I|Stack]);
pipedrv_deser(Port, <<?T_TUPLE:8, N:8, Rest/binary>>, Stack) ->
    {L, NewStack} = popN(N, Stack),
    pipedrv_deser(Port, Rest, [list_to_tuple(L)|NewStack]);
pipedrv_deser(Port, <<?T_LIST:8, N:32, Rest/binary>>, Stack) ->
    {L, NewStack} = popN(N, Stack),
    pipedrv_deser(Port, Rest, [L|NewStack]);
pipedrv_deser(Port, <<?T_BINARY:8, Len:32/signed, Rest/binary>>, Stack) ->
    <<Bin:Len/binary, Rest2/binary>> = Rest,
    pipedrv_deser(Port, Rest2, [Bin|Stack]);
pipedrv_deser(Port, <<?T_STRING:8, Len:32/signed, Rest/binary>>, Stack) ->
    <<Bin:Len/binary, Rest2/binary>> = Rest,
    pipedrv_deser(Port, Rest2, [binary_to_list(Bin)|Stack]);
pipedrv_deser(_Port, X, Y) ->
    throw({bah, X, Y}).

popN(N, Stack) ->
    popN(N, Stack, []).
popN(0, Stack, Acc) ->
    {Acc, Stack};
popN(N, [foo___foo_nil___|T], Acc) ->
    %% This is the nonsense we put on the stack to represent NIL.  Ignore it.
    popN(N - 1, T, Acc);
popN(N, [H|T], Acc) ->
    popN(N - 1, T, [H|Acc]).


%%%
%%% Begin code included via <custom_erl> tags
%%%


%% @spec (Port, Filename::string(), Opts) -> {ok, LSock::socket()} |
%%                                           {error, Reason::string()}
%%         Port = unixdom_driver_port()
%%         Opts = [Opt]
%% @doc Sets up a UNIX Domain socket to listen on the `Filename' on the local host.
%%      See `gen_tcp:listen/2' and `inet:setopts/2' for a list of available options.
%% @end
listen(Port, Filename, Opts) when is_port(Port) ->
    try
        case open(Port, Filename, 1) of
        {ok,    MasterUSock} -> ok;
        {error, MasterUSock} -> throw({error, {open, MasterUSock}})
        end,

        case getfd(Port, MasterUSock) of
        {ok,    Val} -> ok;
        {error, Val} -> throw({error, {getfd, Val}})
        end,

        case gen_tcp:listen(0, Opts ++ [{fd, Val}]) of
        {ok,    ListenSock} -> {ok, ListenSock};
        {error, ListenSock} -> throw({error, {fdopen, ListenSock}})
        end
    catch {error, {Action, Reason}} ->
        Err = lists:flatten(io_lib:format("~w: ~s", [Action, inet:format_error(Reason)])),
        throw({error, Err})
    end.

%% @spec (Port, Filename::string(), Opts) -> {ok, Sock::socket()} |
%%                                           {error, Reason::string()}
%%         Port = unixdom_driver_port()
%%         Opts = [Opt]
%% @doc Connects to a server on UDS socket associated with the `Filename' on the local host.
%%      See `gen_tcp:connect/2' and `inet:setopts/2' for a list of available options.
%% @end
connect(Port, Filename, Opts) when is_port(Port), is_list(Filename) ->
    try
        case open(Port, Filename, 0) of
        {ok,    ClntSock} -> ok;
        {error, ClntSock} -> throw({error, io_lib:format("Can't open a uds socket: ~w", [ClntSock])})
        end,

        case getfd(Port, ClntSock) of
        {ok,    Fd} -> ok;
        {error, Fd} -> throw({error, io_lib:format("Can't get file descriptor: ~w", [Fd])})
        end,

        case gen_tcp:fdopen(Fd, []) of
        {ok,    Sock} -> ok;
        {error, Sock} -> throw({error, inet:format_error(Sock)})
        end,

        inet_db:register_socket(Sock, inet_tcp),

        case prim_inet:setopts(Sock, Opts) of
        ok            -> {ok, Sock};
        {error, What} -> throw({error, io_lib:format("setopts failed: ~s", [What])})
        end
    catch {error, Error} ->
        throw({error, lists:flatten(Error)})
    end.

%% @spec (LSock::socket()) -> {ok, Sock::socket()} |
%%                            {error, Reason::string()}
%% @doc Accepts an incoming connection request on a listen socket. Socket must be a
%%      socket returned from `listen/3'.  This function blocks indefinitely until a
%%      client connection is established.
%% @end
accept(LSock) ->
    gen_tcp:accept(LSock).

%% @spec (LSock::socket(), Timeout) -> {ok, Sock::socket()} |
%%                                     {error, Reason::string()}
%%          Timeout = integer() | infinity
%% @doc Accepts an incoming connection request on a listen socket. Socket must be a
%%      socket returned from `listen/3'. Timeout specifies a timeout value in ms.
%% @end
accept(LSock, Timeout) ->
    gen_tcp:accept(LSock, Timeout).

%% @spec (LSock::socket()) -> {ok, Ref::integer()}
%% @doc An asynchronous version of `accept/1'.  The caller will receive
%%      `{inet_async, LSock, Ref::integer(), {ok, CliSocket::socket()}}' or
%%      `{inet_async, ListSock, Ref, {error, Reason}}' upon successful/unsuccessful
%%      client connection.  The function needs to be called again in order to
%%      begin asynchronous accept of the next client socket.  When a successful
%%      socket message `{ok, CliSocket::socket()}' is received, the server must
%%      call `set_sockopt/2' function in order to register the socket with the inet
%%      driver.
%% @end
async_accept(LSock) ->
    prim_inet:async_accept(LSock, -1).

%% @spec (Port, Sock::socket()) -> ok | {error, Reason::string()}
%%         Port = unixdom_driver_port()
%% @doc Close a UDS socket previously opened with `connect/3' or `listen/3'.
%% @end
tcp_close(Port, Sock) ->
    case inet:getfd(Sock) of
    {ok, Fd} ->
        gen_tcp:close(Sock),
        case closefd(Port, Fd) of 
        {ok, _} -> ok;
        Error   -> Error
        end;
    Error ->
        Error
    end.

%% @spec (LSock::socket(), Sock::socket()) -> ok | {error, Reason::string()}
%% @doc Set socket options and register `Sock' with inet driver.
%% @end
set_sockopt(ListSock, CliSocket) ->
    true = inet_db:register_socket(CliSocket, inet_tcp),
    case prim_inet:getopts(ListSock, [active, nodelay, keepalive, delay_send]) of
    {ok, Opts} ->
        case prim_inet:setopts(CliSocket, Opts) of
        ok    -> ok;
        Error -> gen_tcp:close(CliSocket), Error
        end;
    Error ->
        gen_tcp:close(CliSocket), Error
    end.


